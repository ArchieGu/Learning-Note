# 接口与抽象类

接口和抽象类是面向对象四大特性，以及很多设计模式、设计思想、设计原则编程实现的基础。

利用接口，实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则。

使用抽象类来实现面向对象的继承特性和模板设计模式。

## 抽象类

抽象类特性：

1. 抽象类不允许被实例化，只能被继承。
2. 抽象类可以包含属性和方法。方法中既可以包含代码实现，也可以不包括实现【抽象方法】
3. 子类继承抽象类必须实现抽象类中所有的**抽象**方法

## 接口

接口特性：

1. 接口不能包含属性（成员变量）
2. 接口只能声明方法，方法内不能包含代码实现
3. 类实现接口的时候，必须实现接口中声明的所有方法

接口同样也不能被实例为对象，只能被子类继承。相对于抽象类的is-a关系，接口类是一种has-a关系，表示具有某些功能。

## 抽象类及接口的意义

如果不利用抽象类，利用普通类的继承关系也能实现代码复用的目的，但是这样就无法使用多态特性。如果在子类中需要新增一个方法，就需要在父类中定义一个同名的空方法，然后再在子类中进行重写实现，这样会造成代码可读性差，以及之后其他子类可能会忘记对该方法进行重写，曾家了类被误用的风险。

**抽象类：代码复用**

**接口类：代码解耦**

如果需要表示一种is-a的关系，并且是为了解决代码复用问题，就使用抽象类；如果表示一种has-a关系，并且是为了解决抽象而非代码复用问题，则使用接口。

从类的继承层次来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（抽象类）。

接口是自上而下的设计思路，在编程的时候一般先设计接口，再考虑具体实现。

# 基于抽象而非实现编程

> Program to an interface, not an implementation.
>
> 基于接口**(抽象)**而非实现编程的原则，是一种非常有效的提高代码质量的手段

应用这条原则，可以将接口与实现分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，当实现发生变化时，上游代码基本上不需要做改动，这样**降低了耦合性，提高了扩展性**。

> 越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。
>
> 好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍能够在不破坏原有代码设计的情况下灵活应对。

注意点：

1. （接口）函数的命名不能暴露任何实现细节，需要改为更加抽象的命名方式
2. 封装具体的实现细节，具体实现中涉及的特殊流程不需要暴露给使用者，对外提供一个包含了所有细节的方法，给调用者使用。
3. 为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的协议。使用者依赖接口，而不是具体的实现类来编程。

`软件开发中，要有抽象意识、封装意识、接口意识；接口定义指表明做什么，而不是怎么做`

# 多用组合少用继承

> 组合优于继承，多用组合少用继承

继承的副作用：**继承层次过深、过复杂，影响代码可读性和可维护性**。

某些子类并不完全包含父类中的方法或属性，使用重写会增加编码工作量，同时也违反了**最小知识原则 (Least Knowledge Principle, 迪米特法则)**，暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。

举例：

设计一个关于鸟的类，由于大部分鸟都会飞，那能否在AbstractBird抽象类中定义一个fly()方法？No，因为有不会飞的鸟，如果继承了这种父类就需要对fly()方法进行重写，增加了编码工作量，同时也违反了**最小知识原则 (Least Knowledge Principle, 迪米特法则)**，暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。

如果在AbstractBird类中再派生更加细分的类，让符合的鸟分别继承。但当遇到更多需要分类的细节后，继承关系的组合会爆炸性增长，类的继承层次越来越深、继承关系越发复杂。

## 组合的优势

利用组合(composition)、接口、委托 (delegation) 可以解决继承存在的问题。

例如，让会飞的鸟继承fly()接口即可，但是接口只声明了方法，不定义实现。如果每个子类都要实现一遍逻辑一样的方法，会导致代码重复的问题。所以针对这些接口，再定义实现类，之后再通过组合和委托技术来消除重复的代码

```java
public interface Flyable {
	void fly();
}

public class FlyAbility implements Flyable{
    @Override
    public void fly() { ... }
}

public class Ostrich implements Tweetable, EggLayable {
    private TweetAbility tweetAbility = new TweetAbility(); //组合
    private EggLayability eggLayAbility = new EggLayAbility(); //组合
    
    @Override
    public void tweet(){
        tweetAbility.tweet(); //委托
    }
    @Override
    public void layEgg(){
        eggLayAbility.layEgg(); //委托
    }
}

```

继承的三个作用：

1. 表示is-a关系：可以利用组合和接口的has-a关系来替代
2. 支持多态：利用接口实现
3. 代码复用：通过组合和委托实现